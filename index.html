<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Merry Christmas Di·ªáu Th·∫£o</title>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&family=Patrick+Hand&display=swap');
    </style>

    <style>
        /* --- C·∫§U H√åNH CHUNG --- */
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #020202; 
            font-family: 'Patrick Hand', cursive; 
        }
        #canvas-container { 
            width: 100vw; 
            height: 100vh; 
            position: absolute; 
            top: 0; left: 0; 
            z-index: 1; 
            cursor: grab; 
        }
        #canvas-container:active { cursor: grabbing; }

        /* --- LOADING SCREEN (ƒê√£ cƒÉn ch·ªânh) --- */
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 1000;
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center;
            transition: opacity 1.2s ease-out;
            pointer-events: none;
            padding: 20px; /* ƒê·ªám ƒë·ªÉ kh√¥ng s√°t l·ªÅ m√†n h√¨nh nh·ªè */
            box-sizing: border-box;
        }
        .loader-text {
            color: #ffd700; 
            font-size: 22px; 
            letter-spacing: 1px; 
            margin-top: 25px; /* Kho·∫£ng c√°ch v·ªõi spinner */
            font-family: 'Dancing Script', cursive;
            text-shadow: 0 0 10px #ffd700;
            text-align: center; /* CƒÉn gi·ªØa vƒÉn b·∫£n */
            line-height: 1.4;
            animation: pulse 1.5s infinite;
            width: 100%;
        }
        .spinner {
            width: 50px; height: 50px; 
            border: 3px solid rgba(255, 215, 0, 0.2); 
            border-top: 3px solid #ffd700; 
            border-radius: 50%; 
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        @keyframes pulse { 0% { opacity: 0.6; } 50% { opacity: 1; } 100% { opacity: 0.6; } }

        /* --- UI LAYER --- */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; 
            pointer-events: none; 
            display: flex; justify-content: center; align-items: center;
        }

        /* PHONG B√å */
        #envelope-icon {
            position: absolute;
            width: 110px; height: 75px;
            background: #c0392b;
            border-radius: 5px;
            box-shadow: 0 0 60px rgba(255, 215, 0, 0.7);
            display: flex; justify-content: center; align-items: center;
            cursor: pointer; pointer-events: auto; 
            
            opacity: 0; 
            transform: scale(0); 
            transition: all 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        /* Phong b√¨ thu nh·ªè g√≥c ph·∫£i */
        #envelope-icon.minimized {
            bottom: 30px; right: 25px; 
            top: auto; left: auto;
            width: 60px; height: 40px;
            transform: scale(1) !important;
            opacity: 0.9 !important;
            box-shadow: none;
            border: 1px solid rgba(255,255,255,0.2);
        }
        #envelope-icon::before {
            content: ''; position: absolute; top: 0; left: 0;
            border-left: 55px solid transparent; 
            border-right: 55px solid transparent;
            border-top: 40px solid #a93226;
            transition: all 0.5s;
        }
        #envelope-icon.minimized::before {
            border-left: 30px solid transparent; 
            border-right: 30px solid transparent;
            border-top: 21px solid #a93226;
        }
        #envelope-icon:hover { transform: scale(1.1); box-shadow: 0 0 80px rgba(255, 215, 0, 1); }
        #envelope-icon .seal {
            font-size: 28px; color: #f1c40f; z-index: 2; margin-top: -12px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        /* L√Å TH∆Ø - CƒÇN CH·ªàNH V·ª™A V·∫∂N */
        #paper-letter {
            position: absolute;
            
            /* K√≠ch th∆∞·ªõc linh ho·∫°t */
            width: 90%; 
            max-width: 400px; /* R·ªông h∆°n x√≠u ƒë·ªÉ ch·ªØ d√†n tr·∫£i ƒë·∫πp */
            height: auto;
            max-height: 65vh; /* Chi·∫øm t·ªëi ƒëa 65% chi·ªÅu cao m√†n h√¨nh */
            
            background-color: #fffdf0;
            background-image: linear-gradient(#e0e0e0 1px, transparent 1px);
            background-size: 100% 30px; /* Kho·∫£ng c√°ch d√≤ng */
            
            /* Padding g·ªçn g√†ng */
            padding: 25px 30px;
            box-sizing: border-box;
            
            box-shadow: 0 10px 40px rgba(0,0,0,0.8); /* B√≥ng ƒë·ªï v·ª´a ph·∫£i */
            border-radius: 6px;
            
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.5s ease;
            pointer-events: auto;
            display: none;
            
            /* Cu·ªôn m∆∞·ª£t n·∫øu ch·ªØ qu√° d√†i */
            overflow-y: auto;
            scrollbar-width: thin;
        }
        #paper-letter::-webkit-scrollbar { width: 4px; }
        #paper-letter::-webkit-scrollbar-thumb { background: #d0d0d0; border-radius: 2px; }

        #paper-letter.visible { opacity: 1; transform: translateY(0); }

        .letter-content { position: relative; color: #2c3e50; font-size: 20px; line-height: 30px; }
        .letter-header { text-align: center; margin-bottom: 15px; border-bottom: 2px dashed #e74c3c; padding-bottom: 8px; }
        .letter-title { font-family: 'Dancing Script', cursive; font-size: 36px; color: #c0392b; margin: 0; }
        
        .letter-body { margin-top: 10px; text-align: justify; /* CƒÉn ƒë·ªÅu 2 b√™n cho ƒë·∫πp */ }
        
        .letter-footer { margin-top: 20px; text-align: right; font-style: italic; color: #7f8c8d; font-size: 17px; }
        
        .btn-group {
            margin-top: 25px; display: flex; gap: 12px; justify-content: center;
        }
        .stamp-btn {
            background: none; border: 2px solid #c0392b; border-radius: 20px;
            padding: 6px 15px; cursor: pointer; font-family: 'Patrick Hand', cursive;
            color: #c0392b; font-size: 16px; font-weight: bold; transition: all 0.2s; flex: 1;
        }
        .stamp-btn:hover { background: #c0392b; color: #fff; }
        .stamp-btn.secondary { border-color: #95a5a6; color: #7f8c8d; }
        .stamp-btn.secondary:hover { background: #95a5a6; color: #fff; }

        /* HINT TEXT */
        #hint {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            color: #ffeaa7; font-size: 18px;
            font-family: 'Dancing Script', cursive;
            pointer-events: none;
            text-shadow: 0 0 15px rgba(255, 200, 0, 0.9);
            animation: fadeHint 3s infinite;
        }
        @keyframes fadeHint { 0%,100%{opacity:0.6} 50%{opacity:1} }

    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div class="loader-text">ƒêang chu·∫©n b·ªã ƒëi·ªÅu b·∫•t ng·ªù<br>d√†nh cho Di·ªáu Th·∫£o...</div>
    </div>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <!-- Phong b√¨ -->
        <div id="envelope-icon" title="M·ªü th∆∞" onclick="openLetter()">
            <div class="seal">‚ù§Ô∏è</div>
        </div>

        <!-- L√° th∆∞ -->
        <div id="paper-letter">
            <div class="letter-content">
                <div class="letter-header">
                    <h1 class="letter-title">Merry Christmas!</h1>
                </div>
                <div class="letter-body">
                    G·ª≠i <b>em b√©</b> xinh ƒë·∫πp,<br><br>
                    Ch√∫c em m·ªôt m√πa Gi√°ng sinh th·∫≠t ·∫•m √°p, an l√†nh, tr√†n ng·∫≠p ni·ªÅm vui v√† lu√¥n t·ªèa s√°ng nh∆∞ nh·ªØng v√¨ sao nha. m√£i y√™u em ‚ú®<br><br>
                    <i>Merry Christmas, my beautiful princess</i> üéÑüéÅ
                </div>
                <div class="letter-footer">From: TinPhat</div>
                
                <div class="btn-group">
                    <button class="stamp-btn secondary" onclick="closeLetter()">ƒê√≥ng th∆∞</button>
                    <button class="stamp-btn" onclick="location.reload()">Xem l·∫°i</button>
                </div>
            </div>
        </div>
    </div>

    <div id="hint">Xoay ƒë·ªÉ ng·∫Øm - Ch·∫°m v√†o c√¢y ƒë·ªÉ nh·∫≠n qu√†</div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- C·∫§U H√åNH ---
        const CONFIG = {
            colors: {
                bg: 0x000000, 
                gold: 0xffd700,
                green: 0x004d00,
                red: 0xff0000
            },
            particles: { count: 1800, dustCount: 2000, treeHeight: 25, treeRadius: 9 }
        };

        const STATE = { mode: 'TREE', hasShattered: false };
        let scene, camera, renderer, composer, controls;
        let mainGroup, clock = new THREE.Clock();
        let particleSystem = []; 
        let starExplosionSystem = []; 
        let isDragging = false, startX = 0, startY = 0;
        let starMesh = null; 

        window.openLetter = function() {
            const letter = document.getElementById('paper-letter');
            const envelope = document.getElementById('envelope-icon');
            envelope.style.opacity = '0';
            envelope.style.pointerEvents = 'none';
            envelope.style.transform = 'scale(0.5)';
            letter.style.display = 'block';
            setTimeout(() => letter.classList.add('visible'), 50);
        };

        window.closeLetter = function() {
            const letter = document.getElementById('paper-letter');
            const envelope = document.getElementById('envelope-icon');
            letter.classList.remove('visible');
            setTimeout(() => {
                letter.style.display = 'none';
                envelope.classList.add('minimized');
                envelope.style.pointerEvents = 'auto';
                envelope.style.opacity = '1';
                envelope.style.transform = 'scale(1)';
            }, 500);
        };

        function init() {
            initThree();
            setupLights();
            createParticles(); 
            createDust();     
            setupPostProcessing();
            setupInteraction();
            setTimeout(() => {
                const loader = document.getElementById('loader');
                loader.style.opacity = 0;
                setTimeout(() => loader.remove(), 1000);
            }, 1000);
            animate();
        }

        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.colors.bg);
            scene.fog = new THREE.FogExp2(CONFIG.colors.bg, 0.015);
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 50); 
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ReinhardToneMapping; 
            renderer.toneMappingExposure = 2.5;
            container.appendChild(renderer.domElement);
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; controls.dampingFactor = 0.05;
            controls.enableZoom = true; controls.autoRotate = true; controls.autoRotateSpeed = 2.0;
            controls.enablePan = false; controls.maxPolarAngle = Math.PI / 1.5;
            controls.minDistance = 20; controls.maxDistance = 80;
            mainGroup = new THREE.Group();
            scene.add(mainGroup);
        }

        function setupLights() {
            const ambient = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambient);
            const centerLight = new THREE.PointLight(0xffaa00, 4, 40);
            centerLight.position.set(0, 10, 0);
            mainGroup.add(centerLight);
            const spot1 = new THREE.SpotLight(0xffdd44, 800);
            spot1.position.set(40, 50, 40); scene.add(spot1);
            const spot2 = new THREE.SpotLight(0x4488ff, 500);
            spot2.position.set(-40, 20, -40); scene.add(spot2);
        }

        function setupPostProcessing() {
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.15; bloomPass.strength = 1.0; bloomPass.radius = 0.5;
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
        }

        class Particle {
            constructor(mesh, type, isDust = false) {
                this.mesh = mesh; this.type = type; this.isDust = isDust;
                this.posTree = new THREE.Vector3();
                this.posScatter = new THREE.Vector3();
                this.baseScale = mesh.scale.x; 
                this.spinSpeed = new THREE.Vector3((Math.random()-0.5)*3, (Math.random()-0.5)*3, 0);
                this.calculatePositions();
            }
            calculatePositions() {
                const h = CONFIG.particles.treeHeight;
                const halfH = h/2;
                if (this.type === 'STAR') {
                    this.posTree.set(0, halfH + 5, 0);
                    this.posScatter.set(0, halfH + 5, 0); 
                    return;
                }
                let t = Math.random(); t = Math.pow(t, 0.85); 
                const y = (t*h)-halfH+4;
                let rMax = CONFIG.particles.treeRadius*(1.0-t); 
                const angle = t*25*Math.PI + Math.random()*Math.PI*2; 
                const r = rMax*(0.6+Math.random()*0.4); 
                this.posTree.set(Math.cos(angle)*r, y, Math.sin(angle)*r);
                const rScatter = 15 + Math.random()*45; 
                const theta = Math.random()*Math.PI*2;
                const phi = Math.acos(2*Math.random()-1);
                this.posScatter.set(rScatter*Math.sin(phi)*Math.cos(theta), rScatter*Math.sin(phi)*Math.sin(theta), rScatter*Math.cos(phi));
            }
            update(dt, mode) {
                if (this.type === 'STAR' && mode === 'SCATTER') {
                    this.mesh.scale.lerp(new THREE.Vector3(0,0,0), 10 * dt);
                    return;
                }
                let target = (mode === 'TREE') ? this.posTree : this.posScatter;
                let lerpSpeed = (mode === 'SCATTER') ? 0.5 : 3.0; 
                if (mode === 'SCATTER') {
                    this.mesh.rotation.x += this.spinSpeed.x * dt * 0.5;
                    this.mesh.rotation.y += this.spinSpeed.y * dt * 0.5;
                } else {
                    this.mesh.lookAt(0, this.mesh.position.y, 0);
                }
                this.mesh.position.lerp(target, lerpSpeed * dt);
                if (this.isDust || this.type === 'GOLD') {
                    const s = this.baseScale * (0.6 + 0.4 * Math.sin(clock.elapsedTime * 3 + this.mesh.id));
                    this.mesh.scale.setScalar(s);
                }
            }
        }

        class StarDust {
            constructor(origin) {
                const geo = new THREE.OctahedronGeometry(0.15, 0); 
                const mat = new THREE.MeshBasicMaterial({ color: 0xffffaa });
                this.mesh = new THREE.Mesh(geo, mat);
                this.mesh.position.copy(origin);
                const speed = 2 + Math.random() * 8;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                this.velocity = new THREE.Vector3(
                    Math.sin(phi) * Math.cos(theta),
                    Math.sin(phi) * Math.sin(theta),
                    Math.cos(phi)
                ).multiplyScalar(speed);
                this.life = 1.0; 
                this.decay = 0.3 + Math.random() * 0.5; 
                scene.add(this.mesh);
            }
            update(dt) {
                this.mesh.position.addScaledVector(this.velocity, dt);
                this.velocity.y -= 2 * dt; 
                this.velocity.multiplyScalar(0.95); 
                this.life -= this.decay * dt;
                this.mesh.scale.setScalar(this.life);
                if (this.life <= 0) { this.mesh.visible = false; }
            }
        }

        function createParticles() {
            const boxGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4); 
            const sphereGeo = new THREE.SphereGeometry(0.25, 16, 16); 
            const goldMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.gold, emissive: 0xffaa00, emissiveIntensity: 0.8, metalness: 0.9, roughness: 0.1 });
            const greenMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.green, metalness: 0.3, roughness: 0.5, emissive: 0x003300, emissiveIntensity: 0.2 });
            const redMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.red, emissive: 0xaa0000, emissiveIntensity: 0.6, metalness: 0.6, roughness: 0.2 });
            for (let i=0; i<CONFIG.particles.count; i++) {
                const rand = Math.random(); let mesh, type;
                if (rand < 0.5) { mesh = new THREE.Mesh(boxGeo, greenMat); type = 'LEAF'; }
                else if (rand < 0.8) { mesh = new THREE.Mesh(sphereGeo, goldMat); type = 'GOLD'; }
                else { mesh = new THREE.Mesh(sphereGeo, redMat); type = 'RED'; }
                const s = 0.4 + Math.random()*0.8; mesh.scale.set(s,s,s);
                mainGroup.add(mesh); particleSystem.push(new Particle(mesh, type, false));
            }
            const starGeo = new THREE.OctahedronGeometry(2.0, 0);
            const starMat = new THREE.MeshStandardMaterial({ color: 0xffdd88, emissive: 0xffd700, emissiveIntensity: 5.0 });
            starMesh = new THREE.Mesh(starGeo, starMat);
            mainGroup.add(starMesh);
            const p = new Particle(starMesh, 'STAR', false);
            particleSystem.push(p);
        }

        function createDust() {
            const geo = new THREE.BufferGeometry();
            const pos = [];
            for(let i=0; i<CONFIG.particles.dustCount; i++) pos.push((Math.random()-0.5)*70, (Math.random()-0.5)*70, (Math.random()-0.5)*70);
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.2, transparent: true, opacity: 0.5, blending: THREE.AdditiveBlending });
            const points = new THREE.Points(geo, mat);
            mainGroup.add(points);
        }

        function setupInteraction() {
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight);
            });
            const container = document.getElementById('canvas-container');
            container.addEventListener('pointerdown', (e) => { isDragging = false; startX = e.clientX; startY = e.clientY; });
            container.addEventListener('pointermove', (e) => { if (Math.abs(e.clientX-startX)>5 || Math.abs(e.clientY-startY)>5) isDragging = true; });
            container.addEventListener('pointerup', (e) => { if (!isDragging && STATE.mode === 'TREE' && !STATE.hasShattered) triggerShatter(); });
        }

        function triggerShatter() {
            STATE.mode = 'SCATTER';
            STATE.hasShattered = true;
            controls.autoRotate = false;
            document.getElementById('hint').style.display = 'none';
            if (starMesh) {
                const origin = starMesh.position.clone();
                for(let i=0; i<150; i++) starExplosionSystem.push(new StarDust(origin));
            }
            setTimeout(() => {
                const envelope = document.getElementById('envelope-icon');
                if (!envelope.classList.contains('minimized')) {
                    envelope.style.opacity = '1';
                    envelope.style.transform = 'scale(1)';
                }
            }, 1500);
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            controls.update();
            particleSystem.forEach(p => p.update(dt, STATE.mode));
            if (STATE.mode === 'SCATTER') {
                for (let i = starExplosionSystem.length - 1; i >= 0; i--) {
                    starExplosionSystem[i].update(dt);
                    if (starExplosionSystem[i].life <= 0) {
                        scene.remove(starExplosionSystem[i].mesh);
                        starExplosionSystem.splice(i, 1);
                    }
                }
            }
            composer.render();
        }

        init();
    </script>
</body>
</html>




